'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Plurality = exports.NOb = exports.NGenerateText = exports.NErrors = undefined;

var _NDict = require('./NDict');

var _NDict2 = _interopRequireDefault(_NDict);

var _SchemaConstants = require('./SchemaConstants');

var _SchemaConstants2 = _interopRequireDefault(_SchemaConstants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function NOb(props) {
	this.t = _SchemaConstants2.default.N.t;
	this.v = _SchemaConstants2.default.N.cv;

	if ('base' in props && props.base in _NDict2.default) {
		var n = _NDict2.default[props.base];
		this.inf = n.inf;
		this.proper = n.proper;
	} else {
		this.inf = props.inf || {};
		this.proper = props.proper || false;
	}

	this.base = props.base || undefined;
	this.plurality = props.plurality || Plurality.Singular;
	this.genative = props.genative || false;
}

var Plurality = {
	'NoneSelected': 1,
	'Singular': 100,
	'Plural': 200

	// 326. can be the head of a NP
};var NErrors = {
	'REQUESTED_INFLECTION_UNDEFINED': 'The requested inflection is undefined for this noun.'
};

var NGenerateText = function NGenerateText(nob) {

	var retVal = void 0;

	var inf_key = 's'; // by default we will use the singular, non-genative inflection
	switch (nob.plurality) {
		case Plurality.Plural:
			inf_key = nob.genative ? 'pg' : 'p';
			break;
		default:
			inf_key = nob.genative ? 'sg' : 's';
	}

	if (inf_key in nob.inf) retVal = nob.inf[inf_key];else retVal = { e: NErrors.REQUESTED_INFLECTION_UNDEFINED };

	if (!retVal.e) retVal = nob.proper ? retVal.charAt(0).toUpperCase() + retVal.slice(1) : retVal;

	return retVal;
};

exports.NErrors = NErrors;
exports.NGenerateText = NGenerateText;
exports.NOb = NOb;
exports.Plurality = Plurality;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9OLmpzIl0sIm5hbWVzIjpbIk5PYiIsInByb3BzIiwidCIsIk4iLCJ2IiwiY3YiLCJiYXNlIiwibiIsImluZiIsInByb3BlciIsInVuZGVmaW5lZCIsInBsdXJhbGl0eSIsIlBsdXJhbGl0eSIsIlNpbmd1bGFyIiwiZ2VuYXRpdmUiLCJORXJyb3JzIiwiTkdlbmVyYXRlVGV4dCIsIm5vYiIsInJldFZhbCIsImluZl9rZXkiLCJQbHVyYWwiLCJlIiwiUkVRVUVTVEVEX0lORkxFQ1RJT05fVU5ERUZJTkVEIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7OztBQUVBLFNBQVNBLEdBQVQsQ0FBYUMsS0FBYixFQUFvQjtBQUNuQixNQUFLQyxDQUFMLEdBQVMsMEJBQU9DLENBQVAsQ0FBU0QsQ0FBbEI7QUFDQSxNQUFLRSxDQUFMLEdBQVMsMEJBQU9ELENBQVAsQ0FBU0UsRUFBbEI7O0FBRUEsS0FBSSxVQUFVSixLQUFWLElBQW1CQSxNQUFNSyxJQUFOLG1CQUF2QixFQUE4QztBQUM3QyxNQUFNQyxJQUFJLGdCQUFRTixNQUFNSyxJQUFkLENBQVY7QUFDQSxPQUFLRSxHQUFMLEdBQWNELEVBQUVDLEdBQWhCO0FBQ0EsT0FBS0MsTUFBTCxHQUFjRixFQUFFRSxNQUFoQjtBQUNBLEVBSkQsTUFJTztBQUNOLE9BQUtELEdBQUwsR0FBY1AsTUFBTU8sR0FBTixJQUFhLEVBQTNCO0FBQ0EsT0FBS0MsTUFBTCxHQUFjUixNQUFNUSxNQUFOLElBQWdCLEtBQTlCO0FBQ0E7O0FBRUQsTUFBS0gsSUFBTCxHQUFpQkwsTUFBTUssSUFBTixJQUFjSSxTQUEvQjtBQUNBLE1BQUtDLFNBQUwsR0FBaUJWLE1BQU1VLFNBQU4sSUFBbUJDLFVBQVVDLFFBQTlDO0FBQ0EsTUFBS0MsUUFBTCxHQUFpQmIsTUFBTWEsUUFBTixJQUFrQixLQUFuQztBQUNBOztBQUVELElBQU1GLFlBQVk7QUFDakIsaUJBQWUsQ0FERTtBQUVqQixhQUFhLEdBRkk7QUFHakIsV0FBYTs7QUFHZDtBQU5rQixDQUFsQixDQU9BLElBQU1HLFVBQVU7QUFDZixtQ0FBaUM7QUFEbEIsQ0FBaEI7O0FBSUEsSUFBTUMsZ0JBQWdCLFNBQWhCQSxhQUFnQixDQUFDQyxHQUFELEVBQVM7O0FBRTlCLEtBQUlDLGVBQUo7O0FBRUEsS0FBSUMsVUFBVSxHQUFkLENBSjhCLENBSVo7QUFDbEIsU0FBT0YsSUFBSU4sU0FBWDtBQUNDLE9BQUtDLFVBQVVRLE1BQWY7QUFDQ0QsYUFBVUYsSUFBSUgsUUFBSixHQUFlLElBQWYsR0FBc0IsR0FBaEM7QUFDQTtBQUNEO0FBQ0NLLGFBQVVGLElBQUlILFFBQUosR0FBZSxJQUFmLEdBQXNCLEdBQWhDO0FBTEY7O0FBUUEsS0FBR0ssV0FBV0YsSUFBSVQsR0FBbEIsRUFDQ1UsU0FBU0QsSUFBSVQsR0FBSixDQUFRVyxPQUFSLENBQVQsQ0FERCxLQUdDRCxTQUFTLEVBQUNHLEdBQUVOLFFBQVFPLDhCQUFYLEVBQVQ7O0FBR0QsS0FBRyxDQUFFSixPQUFPRyxDQUFaLEVBQ0NILFNBQVVELElBQUlSLE1BQUwsR0FBZVMsT0FBT0ssTUFBUCxDQUFjLENBQWQsRUFBaUJDLFdBQWpCLEtBQWlDTixPQUFPTyxLQUFQLENBQWEsQ0FBYixDQUFoRCxHQUFrRVAsTUFBM0U7O0FBRUQsUUFBT0EsTUFBUDtBQUNBLENBdkJEOztRQXlCUUgsTyxHQUFBQSxPO1FBQ0FDLGEsR0FBQUEsYTtRQUNBaEIsRyxHQUFBQSxHO1FBQ0FZLFMsR0FBQUEsUyIsImZpbGUiOiJOLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE5EaWN0T2IgZnJvbSAnLi9ORGljdCdcbmltcG9ydCBTY2hlbWEgIGZyb20gJy4vU2NoZW1hQ29uc3RhbnRzJ1xuXG5mdW5jdGlvbiBOT2IocHJvcHMpIHtcblx0dGhpcy50ID0gU2NoZW1hLk4udFxuXHR0aGlzLnYgPSBTY2hlbWEuTi5jdlxuXG5cdGlmICgnYmFzZScgaW4gcHJvcHMgJiYgcHJvcHMuYmFzZSBpbiBORGljdE9iKSB7XG5cdFx0Y29uc3QgbiA9IE5EaWN0T2JbcHJvcHMuYmFzZV1cblx0XHR0aGlzLmluZiAgICA9IG4uaW5mXG5cdFx0dGhpcy5wcm9wZXIgPSBuLnByb3BlclxuXHR9IGVsc2Uge1xuXHRcdHRoaXMuaW5mICAgID0gcHJvcHMuaW5mIHx8IHt9XG5cdFx0dGhpcy5wcm9wZXIgPSBwcm9wcy5wcm9wZXIgfHwgZmFsc2Vcblx0fVxuXG5cdHRoaXMuYmFzZSAgICAgID0gcHJvcHMuYmFzZSB8fCB1bmRlZmluZWRcblx0dGhpcy5wbHVyYWxpdHkgPSBwcm9wcy5wbHVyYWxpdHkgfHwgUGx1cmFsaXR5LlNpbmd1bGFyXG5cdHRoaXMuZ2VuYXRpdmUgID0gcHJvcHMuZ2VuYXRpdmUgfHwgZmFsc2Vcbn1cblxuY29uc3QgUGx1cmFsaXR5ID0ge1xuXHQnTm9uZVNlbGVjdGVkJzoxLFxuXHQnU2luZ3VsYXInOiAgMTAwLFxuXHQnUGx1cmFsJzogICAgMjAwLFxufVxuXG4vLyAzMjYuIGNhbiBiZSB0aGUgaGVhZCBvZiBhIE5QXG5jb25zdCBORXJyb3JzID0ge1xuXHQnUkVRVUVTVEVEX0lORkxFQ1RJT05fVU5ERUZJTkVEJzonVGhlIHJlcXVlc3RlZCBpbmZsZWN0aW9uIGlzIHVuZGVmaW5lZCBmb3IgdGhpcyBub3VuLidcbn1cblxuY29uc3QgTkdlbmVyYXRlVGV4dCA9IChub2IpID0+IHtcblxuXHRsZXQgcmV0VmFsXG5cblx0bGV0IGluZl9rZXkgPSAncycgLy8gYnkgZGVmYXVsdCB3ZSB3aWxsIHVzZSB0aGUgc2luZ3VsYXIsIG5vbi1nZW5hdGl2ZSBpbmZsZWN0aW9uXG5cdHN3aXRjaChub2IucGx1cmFsaXR5KSB7XG5cdFx0Y2FzZSBQbHVyYWxpdHkuUGx1cmFsOlxuXHRcdFx0aW5mX2tleSA9IG5vYi5nZW5hdGl2ZSA/ICdwZycgOiAncCdcblx0XHRcdGJyZWFrXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGluZl9rZXkgPSBub2IuZ2VuYXRpdmUgPyAnc2cnIDogJ3MnXG5cdH1cblxuXHRpZihpbmZfa2V5IGluIG5vYi5pbmYpXG5cdFx0cmV0VmFsID0gbm9iLmluZltpbmZfa2V5XVxuXHRlbHNlXG5cdFx0cmV0VmFsID0ge2U6TkVycm9ycy5SRVFVRVNURURfSU5GTEVDVElPTl9VTkRFRklORUR9XG5cblxuXHRpZighKHJldFZhbC5lKSlcblx0XHRyZXRWYWwgPSAobm9iLnByb3BlcikgPyByZXRWYWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyByZXRWYWwuc2xpY2UoMSkgOiByZXRWYWxcblxuXHRyZXR1cm4gcmV0VmFsXG59XG5cbmV4cG9ydCB7TkVycm9yc31cbmV4cG9ydCB7TkdlbmVyYXRlVGV4dH1cbmV4cG9ydCB7Tk9ifVxuZXhwb3J0IHtQbHVyYWxpdHl9XG4iXX0=