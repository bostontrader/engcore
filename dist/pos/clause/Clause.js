'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ClauseErrors = undefined;

var _POS = require('../POS');

var _POS2 = _interopRequireDefault(_POS);

var _SchemaConstants = require('../SchemaConstants');

var _SchemaConstants2 = _interopRequireDefault(_SchemaConstants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// p51
// use secondary, plain-form if the clause is...
// imperative, subjunctive, to-infinitival, -or- bare infinitival

// look at the clause config and determine finite, non-finite
// finite clauses have as a head a primary form of a verb  -or- a plain form used in imperative or subjunctive.
// non-finite have as a head a gerund-participle or past participle form -or- a plain form used in the infinitival
function Clause(props) {
	this.t = _SchemaConstants2.default.Clause.t;
	this.v = _SchemaConstants2.default.Clause.cv;

	// p50 the head of a clause, aka the predicate is a VP
	if (props) {
		if ('head' in props) this.head = props.head;
		if ('subject' in props) this.subject = props.subject;
		if ('object' in props) this.object = props.object;
	}
}

Clause.prototype = Object.create(new _POS2.default());

var ClauseErrors = {
	'MISSING_HEAD': 'This clause must have a head, aka predicate.'
};

Clause.prototype.analyse = function () {

	if (!('head' in this)) return { t: undefined, e: [ClauseErrors.MISSING_HEAD] };

	var retVal = '';

	if ('subject' in this) retVal = this.subject.analyse().t + ' ' + this.head.analyse().t;else retVal = this.head.analyse().t;

	if ('object' in this) retVal += ' ' + this.object.analyse().t;

	return { t: retVal, e: [] };
};

exports.default = Clause;
exports.ClauseErrors = ClauseErrors;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3MvY2xhdXNlL0NsYXVzZS5qcyJdLCJuYW1lcyI6WyJDbGF1c2UiLCJwcm9wcyIsInQiLCJ2IiwiY3YiLCJoZWFkIiwic3ViamVjdCIsIm9iamVjdCIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsIkNsYXVzZUVycm9ycyIsImFuYWx5c2UiLCJ1bmRlZmluZWQiLCJlIiwiTUlTU0lOR19IRUFEIiwicmV0VmFsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7QUFDQTs7Ozs7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVNBLE1BQVQsQ0FBZ0JDLEtBQWhCLEVBQXVCO0FBQ3RCLE1BQUtDLENBQUwsR0FBUywwQkFBT0YsTUFBUCxDQUFjRSxDQUF2QjtBQUNBLE1BQUtDLENBQUwsR0FBUywwQkFBT0gsTUFBUCxDQUFjSSxFQUF2Qjs7QUFFQTtBQUNBLEtBQUdILEtBQUgsRUFBVTtBQUNULE1BQUcsVUFBVUEsS0FBYixFQUNDLEtBQUtJLElBQUwsR0FBWUosTUFBTUksSUFBbEI7QUFDRCxNQUFHLGFBQWFKLEtBQWhCLEVBQ0MsS0FBS0ssT0FBTCxHQUFlTCxNQUFNSyxPQUFyQjtBQUNELE1BQUcsWUFBWUwsS0FBZixFQUNDLEtBQUtNLE1BQUwsR0FBY04sTUFBTU0sTUFBcEI7QUFDRDtBQUNEOztBQUVEUCxPQUFPUSxTQUFQLEdBQW1CQyxPQUFPQyxNQUFQLENBQWMsbUJBQWQsQ0FBbkI7O0FBRUEsSUFBTUMsZUFBZTtBQUNwQixpQkFBZTtBQURLLENBQXJCOztBQUlBWCxPQUFPUSxTQUFQLENBQWlCSSxPQUFqQixHQUEyQixZQUFXOztBQUVyQyxLQUFHLEVBQUUsVUFBVSxJQUFaLENBQUgsRUFDQyxPQUFPLEVBQUNWLEdBQUVXLFNBQUgsRUFBY0MsR0FBRSxDQUFDSCxhQUFhSSxZQUFkLENBQWhCLEVBQVA7O0FBRUQsS0FBSUMsU0FBUyxFQUFiOztBQUVBLEtBQUcsYUFBYSxJQUFoQixFQUNDQSxTQUFTLEtBQUtWLE9BQUwsQ0FBYU0sT0FBYixHQUF1QlYsQ0FBdkIsR0FBMkIsR0FBM0IsR0FBaUMsS0FBS0csSUFBTCxDQUFVTyxPQUFWLEdBQW9CVixDQUE5RCxDQURELEtBR0NjLFNBQVMsS0FBS1gsSUFBTCxDQUFVTyxPQUFWLEdBQW9CVixDQUE3Qjs7QUFFRCxLQUFHLFlBQVksSUFBZixFQUNDYyxVQUFVLE1BQU0sS0FBS1QsTUFBTCxDQUFZSyxPQUFaLEdBQXNCVixDQUF0Qzs7QUFFRCxRQUFPLEVBQUNBLEdBQUVjLE1BQUgsRUFBV0YsR0FBRSxFQUFiLEVBQVA7QUFFQSxDQWpCRDs7a0JBbUJlZCxNO1FBQ1BXLFksR0FBQUEsWSIsImZpbGUiOiJDbGF1c2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUE9TICAgIGZyb20gJy4uL1BPUydcbmltcG9ydCBTY2hlbWEgZnJvbSAnLi4vU2NoZW1hQ29uc3RhbnRzJ1xuXG4vLyBwNTFcbi8vIHVzZSBzZWNvbmRhcnksIHBsYWluLWZvcm0gaWYgdGhlIGNsYXVzZSBpcy4uLlxuLy8gaW1wZXJhdGl2ZSwgc3VianVuY3RpdmUsIHRvLWluZmluaXRpdmFsLCAtb3ItIGJhcmUgaW5maW5pdGl2YWxcblxuLy8gbG9vayBhdCB0aGUgY2xhdXNlIGNvbmZpZyBhbmQgZGV0ZXJtaW5lIGZpbml0ZSwgbm9uLWZpbml0ZVxuLy8gZmluaXRlIGNsYXVzZXMgaGF2ZSBhcyBhIGhlYWQgYSBwcmltYXJ5IGZvcm0gb2YgYSB2ZXJiICAtb3ItIGEgcGxhaW4gZm9ybSB1c2VkIGluIGltcGVyYXRpdmUgb3Igc3VianVuY3RpdmUuXG4vLyBub24tZmluaXRlIGhhdmUgYXMgYSBoZWFkIGEgZ2VydW5kLXBhcnRpY2lwbGUgb3IgcGFzdCBwYXJ0aWNpcGxlIGZvcm0gLW9yLSBhIHBsYWluIGZvcm0gdXNlZCBpbiB0aGUgaW5maW5pdGl2YWxcbmZ1bmN0aW9uIENsYXVzZShwcm9wcykge1xuXHR0aGlzLnQgPSBTY2hlbWEuQ2xhdXNlLnRcblx0dGhpcy52ID0gU2NoZW1hLkNsYXVzZS5jdlxuXG5cdC8vIHA1MCB0aGUgaGVhZCBvZiBhIGNsYXVzZSwgYWthIHRoZSBwcmVkaWNhdGUgaXMgYSBWUFxuXHRpZihwcm9wcykge1xuXHRcdGlmKCdoZWFkJyBpbiBwcm9wcylcblx0XHRcdHRoaXMuaGVhZCA9IHByb3BzLmhlYWRcblx0XHRpZignc3ViamVjdCcgaW4gcHJvcHMpXG5cdFx0XHR0aGlzLnN1YmplY3QgPSBwcm9wcy5zdWJqZWN0XG5cdFx0aWYoJ29iamVjdCcgaW4gcHJvcHMpXG5cdFx0XHR0aGlzLm9iamVjdCA9IHByb3BzLm9iamVjdFxuXHR9XG59XG5cbkNsYXVzZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG5ldyBQT1MoKSlcblxuY29uc3QgQ2xhdXNlRXJyb3JzID0ge1xuXHQnTUlTU0lOR19IRUFEJzonVGhpcyBjbGF1c2UgbXVzdCBoYXZlIGEgaGVhZCwgYWthIHByZWRpY2F0ZS4nXG59XG5cbkNsYXVzZS5wcm90b3R5cGUuYW5hbHlzZSA9IGZ1bmN0aW9uKCkge1xuXG5cdGlmKCEoJ2hlYWQnIGluIHRoaXMpKVxuXHRcdHJldHVybiB7dDp1bmRlZmluZWQsIGU6W0NsYXVzZUVycm9ycy5NSVNTSU5HX0hFQURdfVxuXG5cdGxldCByZXRWYWwgPSAnJ1xuXG5cdGlmKCdzdWJqZWN0JyBpbiB0aGlzKVxuXHRcdHJldFZhbCA9IHRoaXMuc3ViamVjdC5hbmFseXNlKCkudCArICcgJyArIHRoaXMuaGVhZC5hbmFseXNlKCkudFxuXHRlbHNlXG5cdFx0cmV0VmFsID0gdGhpcy5oZWFkLmFuYWx5c2UoKS50XG5cblx0aWYoJ29iamVjdCcgaW4gdGhpcylcblx0XHRyZXRWYWwgKz0gJyAnICsgdGhpcy5vYmplY3QuYW5hbHlzZSgpLnRcblxuXHRyZXR1cm4ge3Q6cmV0VmFsLCBlOltdfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IENsYXVzZVxuZXhwb3J0IHtDbGF1c2VFcnJvcnN9XG4iXX0=